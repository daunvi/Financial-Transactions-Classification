{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Financial transactions classification - GA Capstone Project\n",
    "\n",
    "This project was done as part of the General Assembly's Data Science Immersive course taken from March to June 2021.\n",
    "\n",
    "## Context and goals\n",
    "\n",
    "After working for a few years in the financial industry, I realised how managing cash flow is an essential skill that companies need to master. More than companies, it can be a nightmare for individuals to follow their day-to-day transactions and be able to categorise different types of spending, especially as transaction details and descriptions on bank statements are far from being straightforward.\n",
    "\n",
    "While researching different ways several players have addressed the issue and talking to industry experts, it appeared that traditional finance has yet to implement features to automatically classify transactions into specific categories. \n",
    "\n",
    "This project aims to:\n",
    "- examine different banking transactional features in order to predict and determine such categories for each transaction\n",
    "- reproduce ML solutions provided by fintech companies to classify transactions\n",
    "\n",
    "<img src=\"./images/app_categories.png\" style=\"float: center; height: 300px\">\n",
    "\n",
    "\n",
    "## Data acquisition and cleaning\n",
    "\n",
    "I received my dataset from a financial tech company that compiles financial transactions from different online banking APIs and classifies each transaction in a range of categories.\n",
    "\n",
    "The data was received in csv format and saved in a SQLite database. \n",
    "The data has been provided in 4 csv files:\n",
    "- transactions: table of banking transactional data with 5 features including merchant, amount, currency, transaction_type and category,\n",
    "- account: table providing account types and names\n",
    "- bank_connection: table that enables to link the bank and account tables\n",
    "- bank: table providing bank types and names\n",
    "\n",
    "After extracting and merging the tables from the database, exploratory data analysis was performed through cleaning and visualising variables. The data was prepared for modelling by removing duplicates, outliers, unrelevant columns and missing values. All values occuring only once were removed for simplicity and to avoid issues on predictions when splitting the data. \n",
    "\n",
    "After cleaning, the dataset had 6228 transactions (rows) and 8 features (columns). It displays transactions from 533 distinct accounts and corresponds to transactions over the course of a week in January 2021.\n",
    "\n",
    "Among the 8 features, predictor variables are as follows:\n",
    "\n",
    "| Name | Description | Type | \n",
    "| :--- | :--- | :--- |\n",
    "| merchant | description of the transaction provided by the bank | string variable | \n",
    "| amount | continuous variable with the amount and sign of the transaction | float - continuous variable |\n",
    "| currency | type of currency | string - categorical variable |\n",
    "| transaction_type | type of transaction within each bank | string - categorical variable |\n",
    "| account_type | type of account which includes checking, savings and cryptocurrency accounts | string - categorical variable |\n",
    "| bank_type | type of bank which encompasses traditional banks, credit card accounts and cryptocurrency exchanges | string - categorical variable |\n",
    "| bank_name | name of the bank | string - categorical variable |\n",
    "\n",
    "These enable us to predict our target variable:\n",
    "\n",
    "| Name | Description | Type | \n",
    "| :--- | :--- | :--- |\n",
    "| category | type of spending classified in specific categories | string - categorical variable |\n",
    "\n",
    "This project aims to predict all 18 classes from the **category** variable. All features were kept in order to reproduce real life predictions and simulate whether statistical models can accurately predict these classes. \n",
    "\n",
    "As a result, the baseline for modelling is 0.22.\n",
    "\n",
    "<img src=\"./images/category_frequency.png\" style=\"float: center; height: 500px\"> \n",
    "\n",
    "In this dataset, it is complicated to use correlation functions, heatmaps or pairplots because variables are all categorical and non numerical apart from the amount variable.\n",
    "\n",
    "<img src=\"./images/amount_spread.png\" style=\"float: center; height: 500px\"> \n",
    "\n",
    "The boxplot above shows that some categories have significantly more widespread amounts and that most categories correspond to spendings and therefore have negative amounts. \n",
    "\n",
    "\n",
    "## Feature engineering\n",
    "\n",
    "The analysis was divided in two parts: the first part using only categorical variables and the second part using feature engineering and NLP pre-processing on the merchant description of the transaction. \n",
    "\n",
    "### PART I - Categorical variables\n",
    "\n",
    "In order to prepare the data for PART I, the following steps were applied:\n",
    "- Feature selection: categorical variables and the amount variable were selected\n",
    "- Dummification: categorical variables were dummified\n",
    "- Train-test split: an 80/20 train-test split was applied to the data\n",
    "- Standardisation: the data was standardised using a StandardScaler or a MinMaxScaler (for Naive Bayes modelling)\n",
    "\n",
    "After dummification, the number of features increased to 53.\n",
    "\n",
    "### PART II - Full dataset\n",
    "\n",
    "In order to prepare the data for PART II, the following steps were applied:\n",
    "- Feature selection: all variables including the merchant's description were selected\n",
    "- Train-test split: an 80/20 train-test split was applied to the data\n",
    "- Column transformations: a ColumnTransformer was applied including several steps\n",
    "    - CountVectorizer: each word from the merchant variable was countvectorized and it was decided to keep words that occur at least twice. English stopwords were added but additional lists of words and experimenting with 'ngram_range' would be needed to complete the analysis \n",
    "    - OneHotEncoder: categorical variables were onehotencoded (dummified)\n",
    "\n",
    "After pre-processing, the number of features increased to 1682.\n",
    "\n",
    "The final model pipeline consited of:\n",
    "\n",
    "1. ColumnTransformer including:\n",
    "    - CountVectorizer\n",
    "    - OneHotEncoder\n",
    "2. StandardScaler\n",
    "3. Classification model\n",
    "\n",
    "\n",
    "## Modelling (Machine Learning)\n",
    "\n",
    "After preparing the data, a range of machine learning classification algorithms were deployed to reproduce the classification of transactions as computed for the app feature. \n",
    "Models for multi-class classification such as Logistic Regression, KNeighbors, Decision Trees, Random Forests, Support Vector Machines and Naive Bayes were tested and tuned resulting in accuracy scores well above baseline.\n",
    "\n",
    "### PART I - Categorical variables\n",
    "\n",
    "In PART I, a range of models were tested on the prepared data and below is a recap of the mean CV scores from each model:\n",
    "\n",
    "| Model | CV score | \n",
    "| :--- | :--- |\n",
    "| Logistic Regression | 0.423 |\n",
    "| KNeighbors | 0.478 |\n",
    "| Decision tree | 0.469 |\n",
    "| Random forest | 0.474 |\n",
    "| SVC | 0.451 |\n",
    "| MultinomialNB | 0.406 |\n",
    "| Bagging with Logistic Regression | 0.412 |\n",
    "| Bagging with KNeighbors | 0.506 |\n",
    "| Bagging with Decision tree | 0.495 |\n",
    "| AdaBoost with Logistic Regression | 0.279 |\n",
    "| AdaBoost with Decision tree | 0.465 |\n",
    "| AdaBoost with SVC | 0.346 |\n",
    "| Gradient Boosting | 0.46 |\n",
    "| Voting | 0.485 |\n",
    "| Stacking | 0.486 |\n",
    "\n",
    "The best mean CV score of 0.51 was achieved with KNeighbors classifier passed through a bagging classifier. The variance-bias trade-off and differences between ensemble models were analysed. As expected, stable classifiers (LogisticRegression and SVC) performed poorly with bagging and boosting, while unstable classifiers had better predictions and scores, both as simple models and within ensemble methods. However, interpretability is limited as KNeighbors is the best model and categorical variables which include transaction type, account type, bank name and bank type, are not expected to be great predictors.\n",
    "\n",
    "### PART II - Full dataset\n",
    "\n",
    "In Part II, similar models were tested again to check for improvements due to the NLP pre-processing. The high number of features made the analysis a lot more complex and some gridsearch models had to be stopped due to time constraints. Therefore, a wide range of modelling techniques were used with fairly simple parameters and scores could be further increased with more time and/or computing power.\n",
    "\n",
    "| Model | CV score | \n",
    "| :--- | :--- |\n",
    "| Logistic Regression | 0.787 |\n",
    "| KNeighbors | 0.765 |\n",
    "| Decision tree | 0.737 |\n",
    "| Random forest | 0.772 |\n",
    "| SVC | 0.735 |\n",
    "| MultinomialNB | 0.728 |\n",
    "| Bagging with Logistic Regression | 0.733 |\n",
    "| Bagging with KNeighbors | 0.791 |\n",
    "| Bagging with Decision tree | 0.743 |\n",
    "| AdaBoost with Decision tree | 0.639 |\n",
    "| AdaBoost with SVC | nan |\n",
    "| Gradient Boosting | 0.759 |\n",
    "| Voting | 0.767 |\n",
    "| Stacking | 0.793 |\n",
    "\n",
    "As a result, the pre-processing of the merchant's description significantly increased the scores and the best ensemble model reached a mean CV score of 0.79. \n",
    "\n",
    "<img src=\"./images/confusion_matrix.png\" style=\"float: center; height: 500px\"> \n",
    "\n",
    "Logistic Regression reached a mean CV score of 0.787 compared to 0.792 for the stacking classifier. It was selected as the best model for its better interpretability when compared to ensemble models. On the test set, the model ended up predicting 979 true positives out of 1246 observations. It was observed that most of the wrongly predicted values belonged to the general class. This was expected as it is the largest as well as the default class where transactions are classified when not assigned to other classes. Other misclassifications occurred between groceries and shopping as they are similar classes. It also happened between internal and income classes as they are the only classes with a wide range of positive values.\n",
    "\n",
    "<img src=\"./images/logistic_regression_coef.png\" style=\"float: center; height: 500px\"> \n",
    "\n",
    "The analysis enabled us to better understand how and why variables influence predictions. The NLP pre-processing created features that are strong predictors of certain classes. For instance, words such as \"water\", \"o2\", \"energy\", \"aviva\", \"ee\", \"giffgaff\", \"tv\", \"bt\", \"sky\", \"vodafone\" or \"insurance\" appear to be strong predictors of the bills class while \"rent\" is a positive coefficient for the housing class.\n",
    "\n",
    "The trade-off between recall and precision can be seen in the graph below.\n",
    "\n",
    "<img src=\"./images/precision_recall_curve.png\" style=\"float: center; height: 500px\">\n",
    "\n",
    "The model calculated an optimum point for the General class where precision=0.63 and recall=0.85 for the test data. The trade-off can be easily visualised. If we were to change the threshold and increase the precision to 0.8, the recall would then drop to 0.45 and below and the number of false negatives would increase. Lower classes such as charity, family, health, holidays and housing are much more volatile due to the low number of observations and we would need more data to increase their scores.\n",
    "\n",
    "<img src=\"./images/roc_curve.png\" style=\"float: center; height: 500px\">\n",
    "\n",
    "Both ROC and Precision-Recall curves have high area under the curve for most clasees. This demonstrates high performance across the classification thresholds.\n",
    "\n",
    "## Limitations and next steps\n",
    "\n",
    "In order to enhance the model and to deal with the strong imbalance in the dataset, undersampling and oversampling were applied with Logistic Regression. However, these additional methods did not improve the model. While the model's best scores are well above baseline, a number of limitations and next steps should be mentioned:\n",
    "\n",
    "- Increasing the number of observations will contribute to the robustness of the model. The amount of data is not sufficient to properly analyse patterns within a population and draw from relationships or networks between users.\n",
    "- The NLP pre-processing was applied to every word which occurred at least twice in the dataset and could be adjusted to specific groups or lists of words. The real app holds lists of keywords and applies specific rules to speed up classification. For instance, if the merchant's decription includes \"Sainsbury's\" or \"Tesco\", the transaction would automatically be classified in the groceries class. Adding such rules would further improve the model.\n",
    "- The timeframe was not provided, which prevented from carrying timeseries and seasonality analysis.\n",
    "- Some classes could be grouped together in order to reduce the number of classes and strengthen predictions as well as deal with the class imbalance.\n",
    "- Due to time constraints, most of the models' gridsearch parameters had to be simplified because they were taking too long to run. As a result, the full project's gridsearches would have to be run again in order to get optimal results.\n",
    "- Methods such as principal component analysis, clustering or neural networks were not explored due to time constraints and further analysis would be needed to improve the model.\n",
    "- Finally, using cloud computing services such as instances on Amazon Web Services to increase the computational power will reduce the waiting time for models to run.\n",
    "\n",
    "DISCLAIMER: the data has been anonymised and no private banking data is displayed.\n",
    "\n",
    "## Conclusions and key learnings\n",
    "\n",
    "A number of limitations and next steps were outlined and further analysis coupled with additional data will be required to improve the model and maximise the results. A future project will be to create a web application to visualise results and to apply our findings to new data. This would make the results interactive and keep improving the model. \n",
    "\n",
    "Key takeaways from this project are as follows:\n",
    "- Without using cloud computing machines, fine-tuning on large datasets needs to be done using trial-by-error method as large gridsearches will take too long to run.\n",
    "- Using NLP pre-processing on the merchant description of transactions, our model managed to predict 79% of categories right. As a result, adding more data coupled with rules and groups of words related to each category will increase our predictions accuracy even further.\n",
    "\n",
    "Overall, this project successfully predicted and classified transactions into specific categories using several pre-processing techniques and machine learning algorithms.\n",
    "\n",
    "## Required dependencies and how to run the project\n",
    "\n",
    "In order to run the project, some Python librairies need to be installed:\n",
    "\n",
    "```\n",
    "pandas\n",
    "numpy\n",
    "matplotlib\n",
    "scikitplot\n",
    "seaborn\n",
    "joblib\n",
    "sqlite3\n",
    "sklearn\n",
    "imblearn\n",
    "```\n",
    "\n",
    "As previously mentioned, some models were quite computationally intensive. As a result, all parameters and results from our machine learning models were saved using 'joblib'. In order to make the analysis quicker, one needs to:\n",
    "- run all cells up to 5.2 (simple classification models)\n",
    "- run 6.1 (feature engineering) and the first two cells of 6.2 (simple classification models with unrestricted vocabulary)\n",
    "- run the reload cells (reload and reassign names) that can be found in the conclusion parts (5.6 and 6.6) in order to get all results from this project\n",
    "- run any other cell as needed to reload graphs and tables"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": false,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": true
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
